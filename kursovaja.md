# Введение

Тема курсовой работы: «Проектирование и разработка структуры данных подсистемы выдачи сертификатов в детском технопарке "Кванториум фотоника"».

Цель - представить разработанную структуру, обеспечить генерацию, хранение и обработку сертификатов.

Задачи:
1. Изучить существующие системы.
2. Изучить процесс выдачи сертификатов.
3. Выбрать и обосновать СУБД.
4. Спроектировать структуру данных.
5. Реализовать прототип и произвести тестирование.


# Изучение существующих систем

Для исследования системы выдачи сертификатов были изучены такие сервисы как Технониколь и Интуит. В ходе исследования устанавливались такие факты как работа поиска конкретного сертификата, перечень необходимых полей для поиска сертификата, а так же несанкционированный просмотр сертификатов.

В ходе изучения работы сервисов выдачи сертификатов был выявлен ряд негативных моментов:

1) Есть возможность получить доступ к сертификату путем простого перебора необходимых параметров, а именно - фамилию и номер сертификата. В данном случае было достаточно ручного перебора, а не автоматического.

2) Сам сертификат не имеет системы проверки подлинности. Тем самым появляется возможность самостоятельно создавать подложные сертификаты используя графический редактор. Данный недостаток частично перекрывается тем, что заинтересованная сторона может проверить номер подложного сертификата в интернете. Однако в таком случае должно быть наличие корректно работающего сайта, а так же должен быть доступ в интернет.

Таким образом были выявлены необходимые требования к системе выдачи сертификатов:

1) Код сертификата должен быть достаточно криптостойким, чтобы противостоять перебору.

2) Ссылка для просмотра сертификата должна работать только один раз.

3) Должна быть возможность проверки сертификата оффлайн при просмотре бумажной копии сертификата, а так же его изображения.

Исходя из полученной информации было выявлено, каким образом сертификат должен проверяться на наличие/отсутствие.


## 1.1 Обеспечение криптостойкости копии сертификата

Криптографическая стойкость (или криптостойкость) — способность криптографического алгоритма противостоять криптоанализу. Стойким считается алгоритм, успешная атака на который требует от атакующего обладания недостижимым на практике объёмом вычислительных ресурсов или перехваченных открытых и зашифрованных сообщений либо настолько значительных затрат времени на раскрытие, что к его моменту защищённая информация утратит свою актуальность. В большинстве случаев криптостойкость не может быть математически доказана; можно только доказать уязвимости криптографического алгоритма либо (в случае криптосистем с открытым ключом) свести задачу вскрытия алгоритма к некоторой задаче, которая считается вычислительно сложной (то есть доказать, что «взлом» не легче решения этой задачи). 

### Типы криптостойких систем шифрования

#### Абсолютно стойкие системы

Доказательство существования абсолютно стойких алгоритмов шифрования было выполнено Клодом Шенноном и опубликовано в работе «Теория связи в секретных системах». Там же определены требования к такого рода системам:

1. Ключ генерируется для каждого сообщения (каждый ключ используется один раз).
2. Ключ статистически надёжен (то есть вероятности появления каждого из возможных символов равны, символы в ключевой последовательности независимы и случайны).
3. Длина ключа равна или больше длины сообщения.
4. Исходный (открытый) текст обладает некоторой избыточностью (является критерием оценки правильности расшифровки).

Стойкость этих систем не зависит от того, какими вычислительными возможностями обладает криптоаналитик. Практическое применение систем, удовлетворяющих требованиям абсолютной стойкости, ограничено соображениями стоимости и удобства пользования.

Некоторыми аналитиками утверждается, что Шифр Вернама является одновременно абсолютно криптографически стойким и к тому же единственным[источник не указан 360 дней] шифром, который удовлетворяет этому условию.

#### Достаточно стойкие системы

В основном применяются практически стойкие или вычислительно стойкие системы. Стойкость этих систем зависит от того, какими вычислительными возможностями обладает криптоаналитик. Практическая стойкость таких систем базируется на теории сложности и оценивается исключительно на какой-то определенный момент времени и последовательно c двух позиций:

1. Вычислительная сложность полного перебора.
2. Известные на данный момент слабости (уязвимости) и их влияние на вычислительную сложность.

В каждом конкретном случае могут существовать дополнительные критерии оценки стойкости.

Сложность алгоритма позволяет оценить, насколько быстро растет его трудоёмкость с увеличением объема входных данных. Под трудоемкостью понимается количество элементарных операций, которые необходимо выполнить для решения задачи с помощью данного алгоритма. Обычно оценка сложности алгоритма представляется в виде O(f(N)), где O – функция сложности, а N – число обрабатываемых наблюдений или примеров. Наименее затратными являются алгоритмы, для которых функция сложности имеет вид f(N) = C и f(N) = C N, где С – константа. В первом случае вычислительные затраты не зависят от количества обрабатываемых данных, а во втором – линейно возрастают. Самыми затратными являются алгоритмы, сложность которых имеет степенную и факториальную зависимости от числа обрабатываемых наблюдений.

### Длина ключа

Количество информации в ключе, как правило, измеряется в битах.

Для современных симметричных алгоритмов (AES, CAST5, IDEA, Blowfish, Twofish) основной характеристикой криптостойкости является длина ключа. Шифрование с ключами длиной 128 бит и выше считается сильным, так как для расшифровки информации без ключа требуются годы работы мощных суперкомпьютеров. Для асимметричных алгоритмов, основанных на проблемах теории чисел (проблема факторизации — RSA, проблема дискретного логарифма — Elgamal) в силу их особенностей минимальная надёжная длина ключа в настоящее время — 1024 бит. Для асимметричных алгоритмов, основанных на использовании теории эллиптических кривых (ECDSA, ГОСТ Р 34.10-2001, ДСТУ 4145-2002), минимальной надёжной длиной ключа считается 163 бит, но рекомендуются длины от 191 бит и выше.

В этой методологии и для шифрования, и для расшифровки отправителем и получателем применяется один и тот же ключ, об использовании которого они договорились до начала взаимодействия. Если ключ не был скомпрометирован, то при расшифровке автоматически выполняется аутентификация отправителя, так как только отправитель имеет ключ, с помощью которого можно зашифровать информацию, и только получатель имеет ключ, с помощью которого можно расшифровать информацию. Так как отправитель и получатель — единственные люди, которые знают этот симметричный ключ, при компрометации ключа будет скомпрометировано только взаимодействие этих двух пользователей. Проблемой, которая будет актуальна и для других криптосистем, является вопрос о том, как безопасно распространять симметричные (секретные) ключи.

Алгоритмы симметричного шифрования используют ключи не очень большой длины и могут быстро шифровать большие объемы данных.

Порядок использования систем с симметричными ключами:

1. Безопасно создается, распространяется и сохраняется симметричный секретный ключ.
2. Отправитель создает электронную подпись с помощью расчета хэш-функции для текста и присоединения полученной строки к тексту.
3. Отправитель использует быстрый симметричный алгоритм шифрования-расшифровки вместе с секретным симметричным ключом к полученному пакету (тексту вместе с присоединенной электронной подписью) для получения зашифрованного текста. Неявно таким образом производится аутентификация, так как только отправитель знает симметричный секретный ключ и может зашифровать этот пакет. Только получатель знает симметричный секретный ключ и может расшифровать этот пакет.
4. Отправитель передает зашифрованный текст. Симметричный секретный ключ никогда не передается по незащищенным каналам связи.
5. Получатель использует тот же самый симметричный алгоритм шифрования-расшифровки вместе с тем же самым симметричным ключом (который уже есть у получателя) к зашифрованному тексту для восстановления исходного текста и электронной подписи. Его успешное восстановление аутентифицирует кого-то, кто знает секретный ключ.
6. Получатель отделяет электронную подпись от текста.
7. Получатель создает другую электронную подпись с помощью расчета хэш-функции для полученного текста.
8. Получатель сравнивает две этих электронных подписи для проверки целостности сообщения (отсутствия его искажения).

Доступными сегодня средствами, в которых используется симметричная методология, являются:

1. Kerberos, который был разработан для аутентификации доступа к ресурсам в сети, а не для верификации данных. Он использует центральную базу данных, в которой хранятся копии секретных ключей всех пользователей.
2. Сети банкоматов (ATM Banking Networks). Эти системы являются оригинальными разработками владеющих ими банков и не продаются. В них также используются симметричные методологии.

### Параметры алгоритмов

Существует множество (не менее двух десятков) алгоритмов симметричных шифров, существенными параметрами которых являются:

1. стойкость
2. длина ключа
3. число раундов
4. длина обрабатываемого блока
5. сложность аппаратной/программной реализации
6. сложность преобразования

### Распространенные алгоритмы

1. AES (англ. Advanced Encryption Standard) — американский стандарт 	шифрования
2. ГОСТ 28147-89 — отечественный стандарт шифрования данных
3. DES (англ. Data Encryption Standard) — стандарт шифрования данных в США до AES
4. 3DES (Triple-DES, тройной DES)
5. RC6 (Шифр Ривеста )
6. Twofish
7. IDEA (англ. International Data Encryption Algorithm)
8. SEED — корейский стандарт шифрования данных
9. Camellia — сертифицированный для использовании в Японии шифр
10. CAST (по инициалам разработчиков Carlisle Adams и Stafford Tavares)
11. XTEA — наиболее простой в реализации алгоритм

Алгоритмы шифрования и дешифрования данных широко применяются в компьютерной технике в системах сокрытия конфиденциальной и коммерческой информации от злонамеренного использования сторонними лицами. Главным принципом в них является условие, что передатчик и приемник заранее знают алгоритм шифрования, а также ключ к сообщению, без которых информация представляет собой всего лишь набор символов, не имеющих смысла.

Классическим примером таких алгоритмов являются симметричные криптографические алгоритмы, перечисленные ниже:

1. Простая перестановка
2. Одиночная перестановка по ключу
3. Двойная перестановка
4. Перестановка «Магический квадрат»

#### Простая перестановка

Простая перестановка без ключа — один из самых простых методов шифрования. Сообщение записывается в таблицу по столбцам. После того, как открытый текст записан колонками, для образования шифровки он считывается по строкам. Для использования этого шифра отправителю и получателю нужно договориться об общем ключе в виде размера таблицы. Объединение букв в группы не входит в ключ шифра и используется лишь для удобства записи несмыслового текста.

#### Одиночная перестановка по ключу

Более практический метод шифрования, называемый одиночной перестановкой по ключу очень похож на предыдущий. Он отличается лишь тем, что колонки таблицы переставляются по ключевому слову, фразе или набору чисел длиной в строку таблицы.

#### Двойная перестановка

Для дополнительной скрытности можно повторно шифровать сообщение, которое уже было зашифровано. Этот способ известен под названием двойная перестановка. Для этого размер второй таблицы подбирают так, чтобы длины ее строк и столбцов были другие, чем в первой таблице. Лучше всего, если они будут взаимно простыми. Кроме того, в первой таблице можно переставлять столбцы, а во второй строки. Наконец, можно заполнять таблицу зигзагом, змейкой, по спирали или каким-то другим способом. Такие способы заполнения таблицы если и не усиливают стойкость шифра, то делают процесс шифрования гораздо более занимательным.

####Перестановка «Магический квадрат»

Магическими квадратами называются квадратные таблицы со вписанными в их клетки последовательными натуральными числами от 1, которые дают в сумме по каждому столбцу, каждой строке и каждой диагонали одно и то же число. Подобные квадраты широко применялись для вписывания шифруемого текста по приведенной в них нумерации. Если потом выписать содержимое таблицы по строкам, то получалась шифровка перестановкой букв. На первый взгляд кажется, будто магических квадратов очень мало. Тем не менее, их число очень быстро возрастает с увеличением размера квадрата. Так, существует лишь один магический квадрат размером 3 х 3, если не принимать во внимание его повороты. Магических квадратов 4 х 4 насчитывается уже 880, а число магических квадратов размером 5 х 5 около 250000. Поэтому магические квадраты больших размеров могли быть хорошей основой для надежной системы шифрования того времени, потому что ручной перебор всех вариантов ключа для этого шифра был немыслим.


### Протокол обмена данными TLS


Протокол SSL был стандартизирован IETF (Internet Engineering Task Force) и
переименован в TLS. Первая выпущенная версия протокола имела название SSL 2.0,
но была довольно быстра заменена на SSL 3.0 из-за обнаруженных уязвимостей.
Как уже упоминалось, SSL был разработан компанией Netscape, так что в январе
1999 года IETF открыто стандартизирует его под именем TLS 1.0. Затем в апреле
2006 года была опубликована версия TLS 1.1, которая расширяла первоначальные
возможности протокола и закрывала известные уязвимости. Актуальная версия
протокола на данный момент – TLS 1.2, выпущенная в августе 2008 года.

Как уже говорилось, TLS был разработан для работы над TCP, однако для работы с
протоколами дейтаграмм, такими как UDP (User Datagram Protocol), была
разработана специальная версия TLS, получившая название DTLS (Datagram
Transport Layer Security).   

Для того чтобы установить криптографически безопасный канал данных, узлы соединения должны согласовать используемые методы шифрования и ключи. Протокол TLS однозначно определяет данную процедуру, подробнее это рассмотрено в пункте TLS Handshake. Следует отметить, что TLS использует криптографию с открытым ключом, которая позволяет узлам установить общий секретный ключ шифрования без каких-либо предварительных знаний друг о друге.

Также в рамках процедуры TLS Handshake имеется возможность установить подлинность личности и клиента, и сервера. Например, клиент может быть уверен, что сервер, которые предоставляет ему информацию о банковском счёте, действительно банковский сервер. И наоборот: сервер компании может быть уверен, что клиент, подключившийся к нему – именно сотрудник компании, а не стороннее лицо (данный механизм называется Chain of Trust и будет рассмотрен в соответствующем разделе).

Наконец, TLS обеспечивает отправку каждого сообщения с кодом MAC (Message Authentication Code), алгоритм создания которого – односторонняя криптографическая функция хеширования (фактически – контрольная сумма), ключи которой известны обоим участникам связи. Всякий раз при отправке сообщения, генерируется его MAC-значение, которое может сгенерировать и приёмник, это обеспечивает целостность информации и защиту от её подмены.

Таким образом, кратко рассмотрены все три механизма, лежащие в основе
криптобезопасности протокола TLS.

Анализируя вышеописанное, был сделан следующий вывод: протокол шифрования, применяемый в TLS нас полностью устраивает, поэтому дальнейшая работа будет учитывать его параметры.

## 1.2 Создание одноразового URL для просмотра сертификата

Одноразовый URL-адрес — это специально созданный адрес, действительный только для одного использования. Обычно он предоставляется пользователю для получения привилегированного доступа к файлу в течение ограниченного времени или как часть определенного действия, такого как проверка учетной записи пользователя. В этой статье я покажу, как создавать, реализовывать и истекать одноразовые URL-адреса.

### Создание URL

Допустим, нам было поручено написать компонент управления пользователями, и проект создает запись для новой учетной записи пользователя в базе данных. После регистрации пользователь получает подтверждение по электронной почте с одноразовым URL-адресом для активации своей учетной записи. Мы можем сделать этот URL-адрес одноразовым, включив параметр отслеживаемого токена, что означает, что URL будет выглядеть следующим образом:

	http://example.com/activate?token= ee97780 ... 

Неудивительно, что отслеживание одноразового URL-адреса выполняется путем сохранения информации в таблице базы данных. Итак, начнем с определения таблицы:

	CREATE TABLE pending_users ( token CHAR(40) NOT NULL, username VARCHAR(45) NOT NULL, tstamp INTEGER UNSIGNED NOT NULL, PRIMARY KEY(token) ); 

В таблице хранится соответствующее имя пользователя, уникальный токен и метка времени. Я покажу, как сгенерировать токен с помощью функции sha1() , которая возвращает строку из 40 символов, следовательно, емкость поля токена tstamp 40. Поле tstamp — это целое поле без знака, используемое для хранения отметки времени, указывающей, когда токен был сгенерирован и может использоваться, если мы хотим реализовать механизм, с помощью которого токен истекает через определенное время.

Есть много способов сгенерировать токен, но здесь я просто буду использовать функции uniqid() и sha1() . Независимо от того, как вы решите сгенерировать свои токены, вам нужно, чтобы они были непредсказуемыми (случайными) и имели низкий шанс дублирования (коллизии).

	<?php $token = sha1(uniqid($username, true)); 

uniqid() принимает строку и возвращает уникальный идентификатор, основанный на строке и текущем времени в микросекундах. Функция также принимает необязательный логический аргумент, чтобы добавить дополнительную энтропию, чтобы сделать результат более уникальным. Функция sha1() вычисляет хэш заданной строки с использованием алгоритма безопасного хэша США 1.

После выполнения функций у нас есть уникальная строка из 40 символов, которую мы можем использовать в качестве токена для создания одноразового URL. Мы хотим записать токен вместе с именем пользователя и отметкой времени в базе данных, чтобы мы могли ссылаться на него позже.

	<?php $query = $db->prepare( "INSERT INTO pending_users (username, token, tstamp) VALUES (?, ?, ?)" ); $query->execute( array( $username, $token, $_SERVER["REQUEST_TIME"] ) ); 

Очевидно, что мы хотим сохранить токен, но мы также сохраняем имя пользователя, чтобы помнить, какого пользователя активировать, и временную метку. В реальном приложении вы, вероятно, сохраните идентификатор пользователя и будете ссылаться на запись пользователя в отдельной пользовательской таблице, но я, например, использую строку имени пользователя. 

С информацией, безопасно помещенной в базу данных, мы можем теперь создать наш одноразовый URL, который указывает на скрипт, который получает токен и обрабатывает его соответственно.

	<?php $url = "http://example.com/activate.php?token=$token"; 

URL может быть передан пользователю по электронной почте или каким-либо другим способом.

	<?php $message = <<<ENDMSG Thank you for signing up at our site. Please go to $url to activate your account. ENDMSG; mail($address, "Activate your account", $message); 

### Использование URL

Нам нужен скрипт для активации учетной записи, как только пользователь перейдет по ссылке. На самом деле, работает сценарий обработки, который обеспечивает одноразовое использование URL. Это означает, что сценарию потребуется извлечь токен из URL-адреса вызывающего и выполнить быструю проверку данных, хранящихся в таблице базы данных. Если это действительный токен, мы можем выполнить любое действие, которое мы хотим, в этом случае активировать пользователя и истечь срок действия токена.

	<?php // retrieve token if (isset($_GET["token"]) && preg_match('/^[0-9A-F]{40}$/i', $_GET["token"])) { $token = $_GET["token"]; } else { throw new Exception("Valid token not provided."); } // verify token $query = $db->prepare("SELECT username, tstamp FROM pending_users WHERE token = ?"); $query->execute(array($token)); $row = $query->fetch(PDO::FETCH_ASSOC); $query->closeCursor(); if ($row) { extract($row); } else { throw new Exception("Valid token not provided."); } // do one-time action here, like activating a user account // ... // delete token so it can't be used again $query = $db->prepare( "DELETE FROM pending_users WHERE username = ? AND token = ? AND tstamp = ?", ); $query->execute( array( $username, $token, $tstamp ) ); 

Если пойти дальше, мы могли бы установить 24-часовой TTL (время жизни) для покупки URL, проверяя временную метку, хранящуюся в таблице рядом с токеном.

	<?php // 1 day measured in seconds = 60 seconds * 60 minutes * 24 hours $delta = 86400; // Check to see if link has expired if ($_SERVER["REQUEST_TIME"] - $tstamp > $delta) { throw new Exception("Token has expired."); } // do one-time action here, like activating a user account // ... 

Работая в области временных отметок Unix, срок действия будет выражен в виде смещения в секундах. Если предполагается, что URL действителен только в течение 24 часов, у нас есть окно 86 400 секунд. Чтобы определить, истек ли срок действия ссылки, становится просто сравнить текущее время с исходной временной меткой и посмотреть, меньше ли разница между ними, чем дельта истечения. Если разница больше дельты, срок действия ссылки должен истечь. Если разница меньше или равна дельте, ссылка все еще «свежая». 


## 1.3 Обеспечение возможности проверки сертификата оффлайн

Иногда люди сталкиваются с необходимостью проверки документов на то, являются ли они подлинными, или же перед вами подделка. В рамках поставленной задачи было принято решение воспользоваться такой технологией как "QR-код".

QR-код (англ. Quick Response Code — код быстрого реагирования; сокр. QR code) — тип матричных штрихкодов (или двумерных штрихкодов), изначально разработанных для автомобильной промышленности Японии. Сам термин является зарегистрированным товарным знаком японской компании «Denso». Штрихкод — считываемая машиной оптическая метка, содержащая информацию об объекте, к которому она привязана. QR-код использует четыре стандартизированных режима кодирования (числовой, буквенно-цифровой, двоичный и кандзи) для эффективного хранения данных; могут также использоваться расширения.

Система QR-кодов стала популярной за пределами автомобильной промышленности благодаря возможности быстрого считывания и большей ёмкости по сравнению со штрихкодами стандарта UPC. Расширения включают отслеживание продукции, идентификацию предметов, отслеживание времени, управление документами и общий маркетинг.

QR-код состоит из чёрных квадратов, расположенных в квадратной сетке на белом фоне, которые могут считываться с помощью устройств обработки изображений, таких как камера, и обрабатываться с использованием кодов Рида — Соломона до тех пор, пока изображение не будет надлежащим образом распознано. Затем необходимые данные извлекаются из шаблонов, которые присутствуют в горизонтальных и вертикальных компонентах изображения. 

### Кодирование данных

Закодировать информацию в QR-код можно несколькими способами, а выбор конкретного способа зависит от того, какие символы используются. Если используются только цифры от 0 до 9, то можно применить цифровое кодирование, если кроме цифр необходимо зашифровать буквы латинского алфавита, пробел и символы $%+-./:, используется алфавитно-цифровое кодирование. Ещё существует кодирование кандзи, которое применяется для шифрования китайских и японских иероглифов, и побайтовое кодирование. Перед каждым способом кодирования создаётся пустая последовательность бит, которая затем заполняется.

#### Цифровое кодирование

Этот тип кодирования требует 10 бит на 3 символа. Вся последовательность символов разбивается на группы по 3 цифры, и каждая группа (трёхзначное число) переводится в 10-битное двоичное число и добавляется к последовательности бит. Если общее количество символов не кратно 3, то если в конце остаётся 2 символа, полученное двузначное число кодируется 7 битами, а если 1 символ, то 4 битами.

Например, есть строка «12345678», которую надо закодировать. Последовательность разбивается на числа: 123, 456 и 78, затем каждое число переводится в двоичный вид: 0001111011, 0111001000 и 1001110, и объединяется это в один битовый поток: 000111101101110010001001110.

#### Буквенно-цифровое кодирование

В отличие от цифрового кодирования, для кодирования 2 символов требуется 11 бит информации. Последовательность символов разбивается на группы по 2, в группе каждый символ кодируется согласно таблице «Значения символов в буквенно-цифровом кодировании». Значение первого символа умножается на 45, затем к этому произведению прибавляется значение второго символа. Полученное число переводится в 11-битное двоичное число и добавляется к последовательности бит. Если в последней группе остаётся один символ, то его значение кодируется 6-битным числом. Рассмотрим на примере: «PROOF». Разбиваем последовательность символов на группы: PR, OO, F. Находим соответствующие значения символам к каждой группе (смотрим в таблицу): PR-(25,27), OO-(24,24), F-(15). Находим значения для каждой группы: 25*45+27=1152, 24*45+24=1104, 15=15. Переводим каждое значение в двоичный вид: 1152=10010000000, 1104= 10001010000, 15=001111. Объединяем в одну последовательность: 1001000000010001010000001111.

#### Байтовое кодирование

Таким способом кодирования можно закодировать любые символы. Входной поток символов кодируется в любой кодировке (рекомендовано в UTF-8), затем переводится в двоичный вид, после чего объединяется в один битовый поток.

Например, слово «Мир» кодируем в Unicode (HEX) в UTF-8: М — D09C; и — D0B8; р — D180. Переводим каждое значение в двоичную систему счисления: D0=11010000, 9C =10011100, D0=11010000, B8=10111000, D1=11010001 и 80=10000000; объединяем в один поток бит: 11010000 10011100 11010000 10111000 11010001 10000000.

#### Кандзи

В основе кодирования иероглифов (как и прочих символов) лежит визуально воспринимаемая таблица или список изображений иероглифов с их кодами. Такая таблица называется «character set». Для японского языка основное значение имеют две таблицы символов: JIS 0208:1997 и JIS 0212:1990. Вторая из них служит в качестве дополнения по отношению к первой. JIS 0208:1997 разбита на 94 страницы по 94 символа. К примеру, страница 4 — хирагана, 5 — катакана, 7 — кириллица, 16—43 — кандзи уровня 1, 48—83 — кандзи уровня 2. Кандзи уровня 1 («JIS дайити суйдзюн кандзи») упорядочены по онам. Кандзи уровня 2 («JIS дайни суйдзюн кандзи») упорядочены по ключам, и внутри них — по количеству черт. 

Составление QR-кода проходит в несколько этапов:

1. Информация кодируется одним из способов (цифровым, буквенно-цифровым, байтовым или кандзи), превращаясь в поток битов — последовательность нулей и единиц;
2. Формируется служебная информация, определяющая версию кода и кодировки;
3. Полученные потоки разбивается на блоки;
4. К каждому блоку добавляются байты коррекции в зависимости от выбранной версии кода;
5. Два блока (исходных данных и коррекции) объединяются в один поток, чтобы получилась последовательность данных.
6. Данные заносятся в поле кода. Для этого пространство, оставшееся после введения обязательных элементов, делится на столбики шириной в два модуля. Они заполняются «змейкой», ноль — белый модуль, единица — черный.


Все это не делается вручную: есть программы и сервисы для кодирования информации. Компания Denso Wave, где были созданы QR-коды, предлагает использовать QRdraw Ad и QR Maker Ad. Для тех, кто не хочет заниматься кодированием «с нуля» есть бесплатные и платные сервисы, в том числе с шаблонами, например: QR coder, QR Code generator, Генератор QR онлайн и другие.

### Распознавание QR-кода

Для пользователя все просто: необходимо навести камеру смартфона, получить уведомление о том, что код распознан, нажать на него. Дальше необходимо либо перейти по ссылке, либо прочитать выведенный текст.

Для приложения в большинстве случаев тоже больших сложностей нет: черные и белые поля легко распознаются, квадраты в углах подсказывают, что именно нужно читать и где расположена системная информация. Затем в основной части кода белые поля превращаются в нули, черные — в единицы. Получается поток данных, из которых потом восстанавливается исходная информация.


# Изучение процесса выдачи сертификатов

## Регистрация на образовательный курс

Первое, что необходимо сделать - это зарегестрироваться на той или иной образовательный курс. Сделать это можно с помощью специальной веб-страницы, на которой нужно заполнить форму регистрации. 

Форма регистрации состоит из некоторого количества полей для заполнения данными. Как правило, это такие поля как: ФИО ребенка, год рождения ребенка, ФИО одного из родителей, адрес проживания, название учебного заведения и так далее. 

После заполнения формы регистрации необходимо ее отправить представителю организации. Как правило, это происходит автоматически. Заполненная форма добавляется в базу данных. Далее, представитель организации предоставляющей курсы должен просмотреть заявки и записать в нужную группу.

После распределения по группам, учащимся высылается из расписние занятий, а так же контактные данные педагога-куратора группы.

## Процесс обучения

После зачисления на курс и распределения по группам у учащихся начинаются занятия, которые проходят по определенному расписанию. У группы есть педагог-куратор, который проводит занятия, отмечает посещаемость, подготавливает задания и отвечает за группу. 

Педагог в конце месяца подводит итоги обучения: выставляет отценки учащимся и заполняет журнал учета занятий. В журнал учета занятий заносятся отведенные часы, темы занятий и посещаемость учащихся. Если учащийся получает низкие оценки и/или пропускает больше дозволенного колличества занятий, то он автоматически исключается из группы. Учащийся, которого исключили, удаляется из общей базы данных.

## Итоговое тестирование

В конце курса педагог проводит итоговое тестирование учащихся. Итоговое тестирование - это набор заданий, которые основаны на темах прошедшего курса. Исходя из результатов тестирования педагог принимает решение, справился ли учащийся. Если учащийся не справился с тестированием, то это значит, что он не освоил необходимые навыки.

## Подготовка документов для выдачи сертификата

После проведения тестирования педагог подготавливает список учащихся, которые справились с итоговым тестированием. Данный список направляется в методический отдел. Представитель методического отдела корректирует общую базу данных. В результате получается база данных учащихся, которые должны получить сертификат об обучении. Данная база данных направляется в отдел печати сертификатов.

Напечатанный сертификат необходимо забрать из отдела выдачи сертификатов. Забрать его может сам учащийся, родитель учащегося или педагог-куротор группы учащегося.


# Выбор и обоснование СУБД

## SQL-базы данных

### Oracle

Oracle RDBMS (она же Oracle Database) на первом месте среди СУБД. Система популярна у разработчиков, проста в использовании, у нее понятная документация, поддержка длинных наименований, JSON, улучшенный тег списка и Oracle Cloud.

Разработчик: Oracle Corporation
Написана на:Assembly, C, C++
Блог: Oracle NoSQL
Скачать: Oracle NoSQL
Последняя версия: 18.3

Особенности:
1. Обрабатывает большие данные.
2. Поддерживает SQL, к нему можно получить доступ из реляционных БД Oracle.
3. Oracle NoSQL Database с Java/C API для чтения и записи данных.

### MySQL

MySQL работает на Linux, Windows, OSX, FreeBSD и Solaris. Можно начать работать с бесплатным сервером, а затем перейти на коммерческую версию. Лицензия GPL с открытым исходным кодом позволяет модифицировать ПО MySQL.

Эта система управления базами данных использует стандартную форму SQL. Утилиты для проектирования таблиц имеют интуитивно понятный интерфейс. MySQL поддерживает до 50 миллионов строк в таблице. Предельный размер файла для таблицы по умолчанию 4 ГБ, но его можно увеличить. Поддерживает секционирование и репликацию, а также Xpath и хранимые процедуры, триггеры и представления.

Разработчик: Oracle Corporation
Написана на C, C++
Последняя версия: 8.0.16
Скачать: MySql

Особенности:
1. Масштабируемость.
2. Лёгкость использования.
3. Безопасность.
4. Поддержка Novell Cluster.
5. Скорость.
6. Поддержка многих операционных систем.

### PosgreSQL

Масштабируемая объектно-реляционная база данных, работающая на Linux, Windows, OSX и некоторых других системах. В PostgreSQL 10 есть такие функции, как логическая репликация, декларативное разбиение таблиц, улучшенные параллельные запросы, более безопасная аутентификация по паролю на основе SCRAM-SHA-256.

Разработчик: PostgreSQL Global Development Group
Написана на C
Используется в компаниях: Apple, Cisco, Fujitsu, Skype, and IMDb
Последняя версия: 11.2
Блог: PostgreSQL
Скачать: PostgreSQL

Особенности:
1. Поддержка табличных пространств, а также хранимых процедур, объединений, представлений и триггеров.
2. Восстановление на момент времени (PITR).
3. Асинхронная репликация.

### MongoDB

Самая популярная NoSQL система управления базами данных. Лучше всего подходит для динамических запросов и определения индексов. Гибкая структура, которую можно модифицировать и расширять. Поддерживает Linux, OSX и Windows, но размер БД ограничен 2,5 ГБ в 32-битных системах. Использует платформы хранения MMAPv1 и WiredTiger.

Разработчик: MongoDB Inc. в 2007
Написана на C++
Последняя версия: 4.1.9
Блог: MongoDB
Скачать: MongoDB

Особенности:
1. Высокая производительность.
2. Автоматическая фрагментация.
3. Работа на нескольких серверах.
4. Поддержка репликации Master-Slave.
5. Данные хранятся в форме документов JSON.
6. Возможность индексировать все поля в документе.
7. Поддержка поиска по регулярным выражениям.

### Redis 

Redis или Remote Dictionary Server — СУБД с открытым исходным кодом, которая снабжена механизмами журналирования и снимков. Поддерживаются списки, строки, хэши, наборы. Используется для БД, брокеров сообщений и кэшей. Все операции в Redis атомарные. Система написана на языке C и поддерживается практически всеми языками программирования.

Разработчик: Salvatore Sanfilippo
Последняя версия: 5.0.5
Блог: Redis
Скачать: Redis

Особенности:
1. Автоматическая обработка отказа.
2. Транзакции.
3. Сценарии LUA.
4. Вытеснение LRU-ключей.
5. Поддержка Publish/Subscribe.

В результате анализа различных СУБД было принято решение остановиться на MySQL, так как она отвечает всем необходимым для задачи параметрам.

# Спроектировать структуру данных.

## Логическая модель

Проектирование базы данных заключается в многоступенчатом описании будущей БД с различной степенью детализации и формализации, в ходе которого производится уточнение и оптимизация её структуры. 	Различают три этапа детализации описания объектов БД и их взаимосвязей по двум основным уровням моделирования системы – логическому и физическому[2]. 

На Логиеском уровне проектирования производится смысловое описание информационного содержания предметной области. В результате определяются моделируемые объекты и их связи. Затем строится концептуальная модель, для создания который применяют различные диаграммы[3].

Такая сущность  как "Квантумы" наполнена информацией о ключевых параметрах квантумы. Сущность "Уровени обучения" состоит из основных характеристик уровени обучения. Сущность "Учащиеся" состоит из основных характеристик учащиеся. Такая сущность  как "Сертификаты" наполнена информацией о ключевых параметрах сертификаты. Сущность "Учебные группы" состоит из основных характеристик учебные группы. Такая сущность  как "Адреса" наполнена информацией о ключевых параметрах адреса. "Классы" предназначено для хранения информации о классы. "Учебные заведения" предназначено для хранения информации о учебные заведения. Такая сущность  как "Города" наполнена информацией о ключевых параметрах города. Такая сущность  как "Приказы" наполнена информацией о ключевых параметрах приказы. "Люди" предназначено для хранения информации о люди. Сущность "Преподаватели" содержит в себе информацию о характеристиках преподаватели. "Родители" предназначено для хранения информации о родители. Сущность "Директора" содержит в себе информацию о характеристиках директора. Сущность "Контактные лица" состоит из основных характеристик контактные лица. 

"Квантумы" содердит атрибут "Название_квантума". "Уровени_обучения" - это сущность, которая содержит атрибуты: "Уровен", "Количество_часов".  "Сертификаты" содердит атрибут "Номер_сертификата". "Учебные_группы" - это сущность, которая содержит атрибуты: "Название_группы", "Год_зачисления".  В сущности "Адреса" есть атрибут "Полный_адрес". В сущности "Классы" есть атрибут "Номер_класса". Сущность "Учебные_заведения" имеет атрибут "Название_учебного_заведения". 

Сущность "Города" имеет атрибут "Название_города". Сущность "Приказы" содержит: "Вид_приказа", "Номер_приказа", "Текст". Сущность "Люди" содержит: "ФИО", "Номер_телефона", "Адрес_електронной_почты". 

К тоже же, было необходимо отношение "Uchashhijsja_Gruppa", арность которого определена как многие ко многим. Исходя из логических отношений была выявлена потребность в отношении "Direktor_Ljudi" с арностью многие ко многим. Исходя из логических отношений была выявлена потребность в отношении "Uchashhijsja_Roditel" с арностью один ко многим. Существует отношение "Adres_Gorod", которое определено арностью один ко многим. К тоже же, было необходимо отношение "Uroven_obuchenija_Gruppa", арность которого определена как один ко многим. Отношение "Uchashhijsja_Prikaz" обладает арностью многие ко многим. Исходя из логических отношений была выявлена потребность в отношении "Prepodavatel_Ljudi" с арностью многие ко многим. К тоже же, было необходимо отношение "Uchebnoe_zavedenie_Direktor", арность которого определена как один ко многим. К тоже же, было необходимо отношение "Uchashhijsja_Adres", арность которого определена как один ко многим. Исходя из логических отношений была выявлена потребность в отношении "Uchebnoe_zavedenie_Kontaktnoe_lico" с арностью один ко многим. Отношение "Uchashhijsja_Uchebnoe_zavedenie" обладает арностью один ко многим. Существует отношение "Kvantum_Prepodavatel", которое определено арностью многие ко многим. Существует отношение "Kvantum_Uroven_obuchenija", которое определено арностью многие ко многим. Отношение "Uchashhijsja_Ljudi" обладает арностью многие ко многим. Существует отношение "Uchebnoe_zavedenie_Adres", которое определено арностью один ко многим. Отношение "Uroven_obuchenija_Prepodavatel" обладает арностью многие ко многим. Отношение "Sertifikat_Prikaz" обладает арностью один ко многим. Отношение "Uchashhijsja_Sertifikat" обладает арностью один ко многим. Исходя из логических отношений была выявлена потребность в отношении "Roditel_Ljudi" с арностью многие ко многим. Существует отношение "Kontaktnoe_lico_Ljudi", которое определено арностью многие ко многим. Исходя из логических отношений была выявлена потребность в отношении "Uchashhijsja_Klass" с арностью один ко многим. 

Существует "Kvantum_Prepodavatel", которая связывает "Квантумы" и "Преподаватели". Существует "Kvantum_Uroven_obuchenija", которая связывает "Квантумы" и "Уровени обучения". Существует "Uroven_obuchenija_Prepodavatel", которая связывает "Уровени обучения" и "Преподаватели". Связь "Uroven_obuchenija_Gruppa" объединяет "Уровени обучения" и "Учебные группы". Существует "Uchashhijsja_Adres", которая связывает "Учащиеся" и "Адреса". "Uchashhijsja_Uchebnoe_zavedenie" - это связь между "Учащиеся" и "Учебные заведения". Связь "Uchashhijsja_Klass" объединяет "Учащиеся" и "Классы". "Uchashhijsja_Ljudi" - это связь между "Учащиеся" и "Люди". Существует "Uchashhijsja_Roditel", которая связывает "Учащиеся" и "Родители". Существует "Uchashhijsja_Gruppa", которая связывает "Учащиеся" и "Учебные группы". "Uchashhijsja_Prikaz" - это связь между "Учащиеся" и "Приказы". "Uchashhijsja_Sertifikat" - это связь между "Учащиеся" и "Сертификаты". "Sertifikat_Prikaz" - это связь между "Сертификаты" и "Приказы". "Adres_Gorod" - это связь между "Адреса" и "Города". "Uchebnoe_zavedenie_Adres" - это связь между "Учебные заведения" и "Адреса". Связь "Uchebnoe_zavedenie_Direktor" объединяет "Учебные заведения" и "Директора". Связь "Uchebnoe_zavedenie_Kontaktnoe_lico" объединяет "Учебные заведения" и "Контактные лица". Существует "Prepodavatel_Ljudi", которая связывает "Преподаватели" и "Люди". Существует "Direktor_Ljudi", которая связывает "Директора" и "Люди". Связь "Kontaktnoe_lico_Ljudi" объединяет "Контактные лица" и "Люди". Существует "Roditel_Ljudi", которая связывает "Родители" и "Люди".

##Физическая модель

На физическом уровне производится построение физической модели базы данных, которое полностью основано на принципах организации данных, реализованных в логической модели базы данных. Физическая модель строится с учетом ограничений, накладываемых возможностями выбранной СУБД[4].

В базе данных существует таблица "Kvantumyi", хранящая в себе данные атрибуты: Nazvanie_kvantuma c типом text и первичный ключ "id". Также в базе есть таблица "Uchebnyie_gruppyi", в которой хранятся следующие данные: Nazvanie_gruppyi c типом text, God_zachisleniya c типом text и первичный ключ "id". В базе данных существует таблица "Klassyi", хранящая в себе данные атрибуты: Nomer_klassa c типом text и первичный ключ "id". В базе данных существует таблица "Roditeli", хранящая в себе данные атрибуты:  и первичный ключ "id". В базе данных есть таблица "Prikazyi", в которой хранятся такие свойства, как Vid_prikaza c типом text, Nomer_prikaza c типом text, Tekst c типом text и первичный ключ "id". Также в базе есть таблица "Goroda", в которой хранятся следующие данные: Nazvanie_goroda c типом text и первичный ключ "id". В базе данных есть таблица "Direktora", в которой хранятся такие свойства, как  и первичный ключ "id". В базе данных есть таблица "Kontaktnyie_litsa", в которой хранятся такие свойства, как  и первичный ключ "id". Также в базе есть таблица "Lyudi", в которой хранятся следующие данные: FIO c типом text, Nomer_telefona c типом text, Adres_elektronnoj_pochtyi c типом text и первичный ключ "id". В базе данных существует таблица "Prepodavateli", хранящая в себе данные атрибуты:  и первичный ключ "id". 

База данных имеет таблицу "Uroveni_obucheniya" с атрибутами: Uroven c типом text, Kolichestvo_chasov c типом text, Uchebnyie_gruppyi_id c типом integer, первичным ключом "id" и внешними ключами: "Uchebnyie_gruppyi_id". База данных имеет таблицу "Adresa", со свойствами Polnyij_adres c типом text, Goroda_id c типом integer, первичным ключом "id" и внешним ключом "Goroda_id". База данных имеет таблицу "Uchebnyie_zavedeniya", со свойствами Nazvanie_uchebnogo_zavedeniya c типом text, Adresa_id c типом integer, Direktora_id c типом integer, Kontaktnyie_litsa_id c типом integer, первичным ключом "id" и внешним ключом "Adresa_id, Direktora_id, Kontaktnyie_litsa_id". База данных имеет таблицу "Sertifikatyi", со свойствами Nomer_sertifikata c типом text, Prikazyi_id c типом integer, первичным ключом "id" и внешним ключом "Prikazyi_id". База данных имеет таблицу "Uchaschiesya", со свойствами Adresa_id c типом integer, Uchebnyie_zavedeniya_id c типом integer, Klassyi_id c типом integer, Roditeli_id c типом integer, Sertifikatyi_id c типом integer, первичным ключом "id" и внешним ключом "Adresa_id, Uchebnyie_zavedeniya_id, Klassyi_id, Roditeli_id, Sertifikatyi_id". База данных содержит таблицу "Kvantum_Prepodavatel" с атрибутами: Kvantumyi_id c типом integer, Prepodavateli_id c типом integer, а также она имеет первичный ключ" id" и внешний ключ:"Kvantumyi_id, Prepodavateli_id". База данных содержит таблицу "Kvantum_Uroven_obuchenija" с атрибутами: Kvantumyi_id c типом integer, Uroveni_obucheniya_id c типом integer, а также она имеет первичный ключ" id" и внешний ключ:"Kvantumyi_id, Uroveni_obucheniya_id". База данных имеет таблицу "Uroven_obuchenija_Prepodavatel" с атрибутами: Uroveni_obucheniya_id c типом integer, Prepodavateli_id c типом integer, первичным ключом "id" и внешними ключами: "Uroveni_obucheniya_id, Prepodavateli_id". База данных имеет таблицу "Uchashhijsja_Ljudi", со свойствами Uchaschiesya_id c типом integer, Lyudi_id c типом integer, первичным ключом "id" и внешним ключом "Uchaschiesya_id, Lyudi_id". База данных имеет таблицу "Uchashhijsja_Gruppa", со свойствами Uchaschiesya_id c типом integer, Uchebnyie_gruppyi_id c типом integer, первичным ключом "id" и внешним ключом "Uchaschiesya_id, Uchebnyie_gruppyi_id". База данных имеет таблицу "Uchashhijsja_Prikaz", со свойствами Uchaschiesya_id c типом integer, Prikazyi_id c типом integer, первичным ключом "id" и внешним ключом "Uchaschiesya_id, Prikazyi_id". База данных имеет таблицу "Prepodavatel_Ljudi" с атрибутами: Prepodavateli_id c типом integer, Lyudi_id c типом integer, первичным ключом "id" и внешними ключами: "Prepodavateli_id, Lyudi_id". База данных имеет таблицу "Direktor_Ljudi" с атрибутами: Direktora_id c типом integer, Lyudi_id c типом integer, первичным ключом "id" и внешними ключами: "Direktora_id, Lyudi_id". База данных содержит таблицу "Kontaktnoe_lico_Ljudi" с атрибутами: Kontaktnyie_litsa_id c типом integer, Lyudi_id c типом integer, а также она имеет первичный ключ" id" и внешний ключ:"Kontaktnyie_litsa_id, Lyudi_id". База данных имеет таблицу "Roditel_Ljudi", со свойствами Roditeli_id c типом integer, Lyudi_id c типом integer, первичным ключом "id" и внешним ключом "Roditeli_id, Lyudi_id".

# Реализовать прототип и произвести тестирование.


## Описание основных функций приложения.

На начальной странице отображаются все учащиеся, которые должны получить сертификат об успешном прохождении курса. Учащиеся распределены по направлениям обучения. Данные об учащихся, которым необходимо выдать сертификат, хранятся в специальном файле.

Чтобы отобразить содержимое направлений, необходимо нажать на название нужного направления.

Для генерации сертификата необходимо нажать на слово "Выдать сертификат". Далее будут сгенерированы png-файлы для всех учащихся выбранного направления. Имя файла также генерируется автоматически.

Сгенерированные сертификаты передаются методисту, который отправляет их на печать. Напечатанные сертификаты отправляются на подпись к директору организации.

